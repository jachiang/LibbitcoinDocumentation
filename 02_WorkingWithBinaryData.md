# 0.2 Working with Binary Data in Libbitcoin

The Libbitcoin Library API is designed to abstract away Bitcoin's binary formats into intuitive classes and methods which are intended to behave similarly to frequently documented constructs (e.g. transactions, signatures and wallets) used to explain and describe how Bitcoin works.

Ultimately, however, the Bitcoin protocol is only formalised at the binary level, where private & public keys, transactions and network messages follow specific serialisation formats in order to be valid.

Therefore, understanding how binary data is handled in Libbitcoin will be helpful during the study of later topics.

## A) Fixed-length Binary Data

We will use the Bitcoin public key point to illustrate fixed-length byte object handling in Libbitcoin. A compressed public key is illustrated below.

![alt text](https://ipfs.io/ipfs/Qmf4Zpqjjmqx9yGkkidRLnqzdc7XRM2kMFajFonR495wDu "Fixed Byte Data")

The first, single byte marker `(02/03 vs. 04)` indicates the type of pubKey `(compressed vs. uncompressed)`. For a compressed public key, the implied y-coordinate is either even `(02)` or odd `(03)`.

In Libbitcoin, the compressed publicKey is represented by the class bc::ec_compressed. It is useful to understand that this class is a type alias of the byte_array<size> type, which in turn is generated by a `std::array` class template.

```c++
//Let us declare a compressed pubKey in Libbitcoin
ec_compressed myPubKey;

//ec_compressed is a type alias of byte_array<33> type
size_t ec_compressed_size = 33; //marker(1) + x-coord(32)
using ec_compressed = byte_array<ec_compressed_size>;

//byte_array<Size> is a type alias of a class template
template <size_t Size>
using byte_array = std::array<uint8_t, Size>;

//For ec_compressed, this template compiles to:
template<size_t 33u>
using byte_array = std::array<uint8_t, 33u>
```
As you can see in the code example above, fixed-length binary in Libbitcoin is commonly compiled down to `std::array<uint8_t, Size>`, with each array element containing 1 byte. This c++ STL class has fixed memory allocation, which avoids additional memory overhead and furthermore helps Libbitcoin enforce specific Bitcoin binary format lengths! You will therefore rarely use the `byte_array` class directly, but rather a type alias named after specific Bitcoin format (private keys, public key hash, merkle root etc.)

## B) Dynamic-length Binary Data

There are also many examples in Bitcoin where a data format may vary in length. In such cases, the Libbitcoin type `bc::data_chunk` is frequently used. We use the HD Wallet `Entropy` binary format as an example.

![alt text](https://ipfs.io/ipfs/QmXbJS6MeFHaYrZoSa96AUTDxexJKqfV16t7Mnah3QHb1z "Dynamic Byte Data")

Now let us try this in Libbitcoin. In order to generate a word list, we first declare an instance of the Libbitcoin class data_chunk, which will contain our generated entropy.

```c++
//data_chunks can contain entropy of various sizes
data_chunk myEntropy16(16);      //128bits allocated
data_chunk myEntropy32(32);      //256bits allocated

//we can now fill our data_chunk with random bits
pseudo_random_fill(myEntropy16); //128bit entropy
pseudo_random_fill(myEntropy32); //256bit entropy

//data_chunk is a type alias:
using data_chunk = std::vector<uint8_t>;
```

The `data_chunk` is a type alias of the versatile `std::vector<uint8_t>` container from the standard STL library.
* The `.data()` method can therefore also be called on `data_chunk` objects to a pointer to the first element. Similarly, the `.size()` method will return the number of elements currently allocated in the byte container.

* A helpful Libbitcoin function is `to_chunk`, which can convert any iterable container, such as a fixed-length `byte_array` into a dynamically-sized `data_chunk`.

```c++
//Let's declare a byte_array of 16 bytes in memory
size_t arraySize = 16;
byte_array<arraySize> myArray;

//pseudo_random_fill expects a data_chunk type input
//yet byte_array isn't implicitly converted to data_chunk
pseudo_random_fill(myArray); //not ok

//so we explicitly convert with our helper fct
pseudo_random_fill(to_chunk(myArray)) //ok
```  
## C) Wrappers for Byte Containers:
Finally, Libbitcoin provides a convenient wrapper for byte containers called `data_slice`, which can be instantiated with any type of iterable byte container, such as `bc::byte_array`, or `bc::data_chunk`.

One especially useful property of `data_slice` is that they can be instantiated with a single byte container argument:

```c++
//Instance of data_slice from a byte_array
byte_array<4u> myArray = {0, 1, 2, 3};
data_slice dataSlice0(myArray); //ok

//Instance of data_slice from a data_chunk
data_chunk myChunk = {0, 1, 2, 3};
data_slice dataSlice1(myChunk); //ok

//error: different underlying classes in wrapper
std::cout << (dataSlice0 == dataSlice1);

```
In the last example above, we can infer that the `data_slice` wrapper is compiled to the type of the input argument it is instantiated with, so that no conversion takes place.

However, functions and methods which are defined with input arguments of type `data_slice`, can accept any iterable byte container type, because these are implicitly converted by the compiler to the `data_slice` type with the single container argument.

```c++
byte_array<4u> myArray = {0, 1, 2, 3};
data_chunk myChunk = {0, 1, 2, 3};

//no implicit conversion: data_chunk -> byte_array
std::cout << (myArray == myChunk);  //throws error

//bitcoin_short_hash() accepts data_slice type input
//byte_array and data_chunk are converted to data_slice
short_hash firstHash = bitcoin_short_hash(myArray);  //ok
short_hash secondHash = bitcoin_short_hash(myChunk); //ok

std::cout << (firstHash == secondHash); //true
```
The function `bitcoin_short_hash`, for example, can therefore be written to accept input arguments of type `data_slice` and accomodate both `byte_array` and `data_chunk` at compile time.

[**Next** -- 0.3 Introduction to Elliptic Curve Math](https://github.com/libbitcoin/libbitcoin/wiki)  
[**Previous** -- 0.1 Getting Started with Libbitcoin (System) ](https://github.com/libbitcoin/libbitcoin/wiki)  
[**Return to Index**](https://github.com/libbitcoin/libbitcoin/wiki)
