# Working with Binary Data in Libbitcoin

The Libbitcoin Library API is designed to abstract away Bitcoin's binary formats into intuitive classes and methods which are intended to behave similarly to frequently documented constructs (e.g. transactions, signatures and wallets) used to explain and describe how Bitcoin works.

However, the Bitcoin protocol is ultimately formalised at the binary level, where public keys, transactions and network messages follow specific serialisation formats in order to be valid.

A brief overview of how binary data is handled in Libbitcoin will be helpful for later topics.

## Fixed-length Binary Data

We will use the Bitcoin public key point to illustrate fixed-length byte object handling in Libbitcoin.

<!-- ![alt text](https://ipfs.io/ipfs/Qmf4Zpqjjmqx9yGkkidRLnqzdc7XRM2kMFajFonR495wDu "Fixed Byte Data") -->

**Compressed Public Key of Fixed Length**
`0228026f91e1c97db3f6453262484ef5f69f71d89474f10926aae24d3c3eeb5f00`

The first single byte marker indicates the type of pubKey: `compressed(02/03) vs. uncompressed(04)`. The following 32 bytes represent the 256 bit x-coordinate of our public key point.

The serialised representation of a Bitcoin public key point is therefore a fixed length of `1 + 32 = 33 bytes`.

In Libbitcoin, the compressed publicKey is represented by the class bc::ec_compressed. It is useful to understand that this class is a type alias of the `byte_array<size>` type, which in turn is generated by a `std::array` class template.

### Example 1

```c++
//Let us declare a compressed pubKey in Libbitcoin
ec_compressed myPubKey;

//ec_compressed is a type alias of byte_array<33> type
constexpr size_t ec_compressed_size = 33; //marker(1) + x-coord(32)
using ec_compressed = byte_array<ec_compressed_size>;

//byte_array<Size> is a type alias of a class template
template <size_t Size>
using byte_array = std::array<uint8_t, Size>;

//For ec_compressed, this template compiles to:
template<size_t 33u>
using byte_array = std::array<uint8_t, 33u>;
```
As you can see in the example above, fixed-length binary in Libbitcoin is commonly compiled down to `std::array<uint8_t, Size>`, with each array element containing 1 byte. This c++ STL class has fixed memory allocation, which avoids additional memory overhead and furthermore helps Libbitcoin enforce specific Bitcoin binary format lengths! You will therefore rarely use the `byte_array` class directly, but rather a type alias named after specific Bitcoin format (private keys, public key hash, merkle root etc.)

## Dynamic-length Binary Data

There are also many examples in Bitcoin where a data format may vary in length. In such a case, the Libbitcoin type `bc::data_chunk` can be used.

We illustrate various valid lengths of HD Wallet mnemonic word list `Entropy` as an example.

<!-- ![alt text](https://ipfs.io/ipfs/QmXbJS6MeFHaYrZoSa96AUTDxexJKqfV16t7Mnah3QHb1z "Dynamic Byte Data") -->

**Different Valid Entropy Sizes for Mnemonic Word Lists**
```
//128 bits
4c05bddb9a3b8347c23830e67e97a299

//160 bits
4c05bddb9a3b8347c23830e67e97a29935c524c5

//192 bits
4c05bddb9a3b8347c23830e67e97a29935c524c5a4fd9397

//224 bits
4c05bddb9a3b8347c23830e67e97a29935c524c5a4fd939713eff634

//256bits
4c05bddb9a3b8347c23830e67e97a29935c524c5a4fd939713eff6344bd1bff8
```


We can generate such predefined entropy lengths with the libbitcoin type `data_chunk` and function `pseudo_random_fill`.

### Example 2

```c++
//data_chunks can contain entropy of various sizes
data_chunk myEntropy16(16);      //128bits allocated
data_chunk myEntropy32(32);      //256bits allocated

//we can now fill our data_chunk with random bits
pseudo_random_fill(myEntropy16); //128bit entropy
pseudo_random_fill(myEntropy32); //256bit entropy

//data_chunk is a type alias:
using data_chunk = std::vector<uint8_t>;
```

The `data_chunk` is a type alias of the versatile `std::vector<uint8_t>` container from the standard STL library.

A helpful Libbitcoin function is `to_chunk`, which can convert any iterable container, such as a fixed-length `byte_array` into a dynamically-sized `data_chunk`.

### Example 3

```c++
//Let's declare a byte_array of 16 bytes in memory
constexpr size_t arraySize = 16;
byte_array<arraySize> myArray;

//pseudo_random_fill expects a data_chunk type input
//yet byte_array isn't implicitly converted to data_chunk
pseudo_random_fill(myArray); //not ok

//so we explicitly convert with our helper fct
data_chunk myChunk = to_chunk(myArray);
pseudo_random_fill(myChunk); //ok
```  
## Passing Byte Containers as Arguments:
There are functions in Libbitcoin which accept both fixed and dynamic length byte containers as arguments.

However, as we observed in example 3, there is no implicit type conversion between types `byte_array` and `data_chunk`.

So Libbitcoin provides a convenient wrapper for all iterable byte containers called `data_slice`.

A function signature which accepts a `data_slice` argument can now accept both fixed and dynamic byte containers, because the compiler will implicitly convert both `byte_array` and `data_chunk` types to `data_slice` at compile time.

### Example 4
```cpp
//bitcoin_short_hash function signature
short_hash bitcoin_short_hash(data_slice data);

byte_array<4u> myArray {{0, 1, 2, 3}};
data_chunk myChunk {0, 1, 2, 3};

auto firstHash = bitcoin_short_hash(myArray);  //ok
auto secondHash = bitcoin_short_hash(myChunk); //ok

std::cout << (firstHash == secondHash); //True
```

A closer look at `data_slice` reveals that it is a type alias of `array_slice<uint8_t>`, which has a single argument constructor used by the compiler for implicit conversion from other iterable byte containers.

```cpp
//array_slice single arg constructor
template <typename Container>
array_slice(const Container& container);

//For a byte_array of length Size, this compiles to
array_slice(const byte_array<Size>& container);

//For a data_chunk, this compiles to
array_slice(const data_chunk& container);
```


[**Next** -- Elliptic Curve Math](https://github.com/libbitcoin/libbitcoin/wiki)  
[**Previous** -- Getting Started with Libbitcoin (System) ](https://github.com/libbitcoin/libbitcoin/wiki)  
[**Return to Index**](https://github.com/libbitcoin/libbitcoin/wiki)
