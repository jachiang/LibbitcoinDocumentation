# Elliptic Curve Operations & Signing

Libbitcoin provides all required elliptic curve primitives and operations required for the creation and management of Bitcoin private keys, public addresses and signatures of transactions and messages.

Bitcoin uses the `secp256k1` elliptic curve `y^2 = x^3 + 7` over the finite field `Fp` where `p = 2^256 - 2^32 - 2^9 - 2^8 - 2^7 - 2^6 - 2^4 - 1`.   

*Note that the value `p` is slightly less than the maximum value an unsigned 256 bit integer can hold.*

All subsequent operations involve either points on the `secp256k1` curve or scalar values which are part of the finite field `Fp`.

## Scalar Private Key Operations

Let us start with scalar values. A Bitcoin private key is simply a secret scalar value which a the member of the finite field `Fp` that is only known to the owner of the derived Bitcoin address.

A private key are randomly generated to avoid any malicious external party from deriving it with the knowledge of a present systematic bias.

### Example 1
```c++
//Generate 256 bit entropy.
data_chunk myEntropy(ec_secret_size); //256bits
pseudo_random_fill(myEntropy);

//Instantiate private key with Entropy
ec_secret mySecret; //256bit byte_array
mySecret = to_array<ec_secret_size>(myEntropy);

//Not all possible 256bits are member of Fp
std::cout << verify(mySecret);
```

We can also add and multiply scalar values in the field `Fp` with `ec_add` and `ec_multiply`. Both operations are commutative.

### Example 2

```c++
//Two scalar values which are members of Fp
ec_secret myScalar1 = base16_literal("f3c8f9a6198cca98f481edde13bcc031b1470a81e367b838fe9e0a9db0f5993d");
ec_secret myScalar2 = base16_literal("04c294ab836b61955e762547c561a45e4be88984dca06da959d47bf880fd92f4");

//Commutative addition:
ec_secret myScalar1_add(myScalar1);
ec_secret myScalar2_add(myScalar2);
ec_add(myScalar1_add, myScalar2);  //myScalar1_add += myScalar2 % p
ec_add(myScalar2_add, myScalar1);  //myScalar2_add += myScalar1 % p
std::cout << (myScalar1_add == myScalar2_add);

//Commutative multiplication:
ec_secret myScalar1_mul(myScalar1);
ec_secret myScalar2_mul(myScalar2);
ec_add(myScalar1_mul, myScalar2);  //myScalar1_mul *= myScalar2 % p
ec_add(myScalar2_mul, myScalar1);  //myScalar2_mul *= myScalar1 % p
std::cout << (myScalar1_mul == myScalar2_mul);
```
## Generating Public Key Points

A Bitcoin public key is simply generated by multiplying the `secp256k1` generator point on the curve with the secret private key scalar value.  

Note there are two Bitcoin formats two represent points on the `secp256k1` elliptic curve. The *uncompressed* point has a single byte `04` prefix followed by 32 bytes representing the x-coordinate and 32 bytes of the representing the y-coordinate.

**Uncompressed elliptic curve point**
```C++
//04 Prefix, x-Coordinate, y-Coordinate  (1 + 32 + 32 bytes)
0279BE667EF9DCBBAC55A06295CE870B07029BFCDB2DCE28D959F2815B16F81798
```

The *compressed* curve point has a leading `02/03` byte followed by only 32 bytes of the x-coordinate. The y-coordinate is implied by the x-coordinate and the marker which indicates an even `(02)` or odd `(03)` y-coordinate.

**Compressed elliptic curve point**
```c++
//02 or 03 Prefix, x-Coordinate(1 + 32 bytes)
0279BE667EF9DCBBAC55A06295CE870B07029BFCDB2DCE28D959F2815B16F81798
```
We will use the uncompressed format in our following examples to generate a Bitcoin public key from a scalar private key.

### Example 3

```c++
//Private Key
ec_secret mySecret = base16_literal("f3c8f9a6198cca98f481edde13bcc031b1470a81e367b838fe9e0a9db0f5993d");

//The secp256k1 Generator Point
ec_compressed pointGen = base16_literal("0279BE667EF9DCBBAC55A06295CE870B07029BFCDB2DCE28D959F2815B16F81798");

//Manually generating the public key
ec_compressed myPubKey_compressed(pointGen);
ec_multiply(myPubKey_compressed,mySecret);

//Better: Using helper fct to generate the public key
ec_compressed myPubKey2;
secret_to_public(myPubKey2, mySecret);

std::cout << (myPubKey_compressed == myPubKey2);
```

**Associativity of EC operators**  
Note that scalar and point operations on the elliptic curve are associative meaning that `point = (r1 + r2) * G = r1 * G + r2 * G`. We omit an example of this as you can easily demonstrate this with the operators documented so far.

EC associativity is an important mathematical property used by extended public keys in HD wallets in later chapters of the Libbitcoin documentation.

## DER Signatures in Bitcoin
Signing a transaction in Bitcoin requires the private key and the tx hash to be signed. The signature itself is composed of two `secp256k1` scalar values `r,s`.

The Libbitcoin type `ec_signature` is a `byte_array<64u>` which contains the two signature values `r,s`.

### Example 4 (Part 1)

```c++
//Hash of an arbitrary msg
byte_array<32u> msg = base16_literal("04c294ab836b61955e762547c561a45e4be88984dca06da959d47bf880fd92f4");
hash_digest myHash = bitcoin_hash(msg);

//My private & public keys
ec_secret mySecret = base16_literal("f3c8f9a6198cca98f481edde13bcc031b1470a81e367b838fe9e0a9db0f5993d");
ec_compressed myPubKey = base16_literal("02b974a3e9fe9ce1ca7f9bb86c114567a51cd8deb7157aeabcce46eb6138c3a1b3");

//Sign hash of TX with my private key
ec_signature mySignature; //r,s
sign(mySignature, mySecret, myHash);

//Verify Signature
std::cout << verify_signature(myPubKey, myHash, mySignature);
```
Although we have now correctly signed the serialised TX message with and produced a valid signature `r,s`, it still needs to be represented in a valid  DER serialisation format to be accepted on the Bitcoin network.  

**Serialised DER Signature Sequence**
* `30` - DER prefix
* `45` - Length of rest of Signature
* `02` - Marker for r value
* `21` - Length of r value
* `00ed...8f` - r value, Big Endian
* `02` - Marker for s value
* `21` - Length of s value
* `7a98...ed` - s value, Big Endian

In Libbitcoin, the the serialised DER signature is represented by the `der_signature` type. Let us serialise our signature from the previous example this way.

### Example 4 (Part 2)
```c++
//Format mySignature (r,s) as a DER signature sequence
der_signature myDerSignature;
encode_signature(myDerSignature, mySignature);

//DER Signature Format (Strict DER Signature)
std::cout << encode_base16(myDerSignature);
```
**Strict DER Signatures**  
Bitcoin implementations have relied on OpenSSL for signing and verification. However, given that OpenSSL in its various releases has deviated from the strict DER standard, BIP66 was proposed to enforce strict DER compliance and is implemented in Libbitcoin.

For example, the DER standard does not allow `r,s` values with first byte values of `>0x7F`, as these are interpreted as negative values. This is ignored by OpenSSL, which makes strict DER signature enforcement necessary.

Libbitcoin has a simple parser function to ensure a DER signature adheres to strict DER encoding.

### Example 4 (Part 3)
```c++
//Parse r,s values from myDerSignature
//Strict enforcement of DER = true
parse_signature(mySignature, myDerSignature, true);
```

### Recoverable Signatures
An interesting property of `secp256k1` signatures of value `r,s` is that it is possible to derive a set of 4 possible pubkey's with knowledge about the signed message, but not the private key.

Given `r,s` and an index `i` ranging from 0 to 3, it is therefore possible to uniquely identify the public key used in the signature.

### Example 4 (Part 4)
```c++
recoverable_signature myRecoverableSig;
sign_recoverable(myRecoverableSig, mySecret, myHash);
std::cout << unsigned(myRecoverableSig.recovery_id);

//recover public key from recoverable signature
ec_compressed recoveredSig;
recover_public(recoveredSig, myRecoverableSig, myHash);

std::cout << (recoveredSig == myPubKey);
```

Recoverable Signatures are used in message signing by wallets to prove ownership of a given address and will be documented in a later chapter.

[**Next** -- Bitcoin Wallets](https://github.com/libbitcoin/libbitcoin/wiki)  
[**Previous** -- Working with Binary Data ](https://github.com/libbitcoin/libbitcoin/wiki)  
[**Return to Index**](https://github.com/libbitcoin/libbitcoin/wiki)
