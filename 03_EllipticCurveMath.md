# Elliptic Curve Operations & Signing

Libbitcoin provides all the necessary elliptic curve primitives and operations required for the generation and management of Bitcoin private keys, public keys and signatures of transactions and messages.

Bitcoin uses the `secp256k1` elliptic curve `y^2 = x^3 + 7` over the finite field `Fp` where `p = 2^256 - 2^32 - 2^9 - 2^8 - 2^7 - 2^6 - 2^4 - 1`.   

*(Note that modulo prime number `p` is slightly less than the maximum value an unsigned 256 bit integer can hold.)*

All subsequent operations involve either scalar members of the finite field `Fp` or valid points on the `secp256k1` curve.

## Scalar Operations

Let us start with scalar values. A Bitcoin private key is simply a secret scalar value which is a the member of the finite field `Fp`.

A private key is randomly generated to prevent any external party from reconstructing it systematically.

**Example 1**
```c++
//Generate 256 bit entropy.
data_chunk myEntropy(ec_secret_size); //256bits
pseudo_random_fill(myEntropy);

//Construct private key with Entropy
ec_secret mySecret; //256bit byte_array
mySecret = to_array<ec_secret_size>(myEntropy);

//Not all possible 256bits are member of Fp
std::cout << verify(mySecret);
```

We can also add and multiply scalar values of the field `Fp` with `ec_add` and `ec_multiply`. Both operations are commutative.

**Example 2**
```c++
//Two scalar values which are members of Fp
ec_secret myScalar1 = base16_literal("f3c8f9a6198cca98f481edde13bcc031b1470a81e367b838fe9e0a9db0f5993d");
ec_secret myScalar2 = base16_literal("04c294ab836b61955e762547c561a45e4be88984dca06da959d47bf880fd92f4");

//Commutative addition:
ec_secret myScalar1_add(myScalar1);
ec_secret myScalar2_add(myScalar2);
ec_add(myScalar1_add, myScalar2);  //myScalar1_add += myScalar2 % p
ec_add(myScalar2_add, myScalar1);  //myScalar2_add += myScalar1 % p
std::cout << (myScalar1_add == myScalar2_add);

//Commutative multiplication:
ec_secret myScalar1_mul(myScalar1);
ec_secret myScalar2_mul(myScalar2);
ec_add(myScalar1_mul, myScalar2);  //myScalar1_mul *= myScalar2 % p
ec_add(myScalar2_mul, myScalar1);  //myScalar2_mul *= myScalar1 % p
std::cout << (myScalar1_mul == myScalar2_mul);
```
## Generating Public Key Points

A Bitcoin public key is simply a point on the `secp256k1` curve generated by multiplying the `secp256k1` generator point with the secret private key scalar value.  

Note that there are two Bitcoin formats that represent points on the `secp256k1` elliptic curve. The *uncompressed* point format has a single byte `04` prefix followed by 32 bytes representing the x-coordinate and another 32 bytes representing the y-coordinate.

**Uncompressed elliptic curve point format**
```C++
//04 Prefix, x-Coordinate, y-Coordinate  (1 + 32 + 32 bytes)
0428026f91e1c97db3f6453262484ef5f69f71d89474f10926aae24d3c3eeb5f00c41b6810b8b305a05de2b4448d7e2a079771d4c018b923a9ab860e4b0b4f86f6
```

The *compressed* curve point format has a leading `02/03` byte followed by 32 bytes of the x-coordinate. The y-coordinate is omitted, yet implied by the x-coordinate and the prefix marker which indicates an even `(02)` or odd `(03)` y-coordinate.

**Compressed elliptic curve point format**
```c++
//02 or 03 Prefix, x-Coordinate(1 + 32 bytes)
0228026f91e1c97db3f6453262484ef5f69f71d89474f10926aae24d3c3eeb5f00
```
We will use the uncompressed format in our following examples to generate a Bitcoin public key curve point from a scalar private key.

**Example 3**
```c++
//Private Key
ec_secret mySecret = base16_literal("f3c8f9a6198cca98f481edde13bcc031b1470a81e367b838fe9e0a9db0f5993d");

//The secp256k1 Generator Point
ec_compressed pointGen = base16_literal("0279BE667EF9DCBBAC55A06295CE870B07029BFCDB2DCE28D959F2815B16F81798");

//Manually generating the public key
ec_compressed myPubKey_compressed(pointGen);
ec_multiply(myPubKey_compressed,mySecret);

//Better: Using helper fct to generate the public key
ec_compressed myPubKey2;
secret_to_public(myPubKey2, mySecret);

std::cout << (myPubKey_compressed == myPubKey2);
```

**Associativity of EC operators**  
Both scalar and point operations on the elliptic curve are associative meaning that `point = (r1 + r2) * G = r1 * G + r2 * G`. You can easily demonstrate this using the Libbitcoin elliptic curve operators documented so far.

EC associativity is an important mathematical property used by extended public keys in [HD Wallets](https://github.com/libbitcoin/libbitcoin/wiki)  .

## DER Signatures in Bitcoin
Signing a transaction in Bitcoin requires both the private key and the transaction hash. The signature itself is composed of two `secp256k1` scalar values `r,s`.

The Libbitcoin type `ec_signature` is a `byte_array<64u>` container which holds the two signature values `r,s`.

**Example 4 (Part 1)**
```c++
//Hash of an arbitrary msg
byte_array<32u> msg = base16_literal("04c294ab836b61955e762547c561a45e4be88984dca06da959d47bf880fd92f4");
hash_digest myHash = bitcoin_hash(msg);

//My private & public keys
ec_secret mySecret = base16_literal("f3c8f9a6198cca98f481edde13bcc031b1470a81e367b838fe9e0a9db0f5993d");
ec_compressed myPubKey = base16_literal("02b974a3e9fe9ce1ca7f9bb86c114567a51cd8deb7157aeabcce46eb6138c3a1b3");

//Sign hash of TX with my private key
ec_signature mySignature; //r,s
sign(mySignature, mySecret, myHash);

//Verify Signature
std::cout << verify_signature(myPubKey, myHash, mySignature);
```
Although we have now correctly signed the serialised TX message and produced a valid signature `r,s`, it still needs to be represented in a valid DER serialisation format to be accepted on the Bitcoin network.  

**Serialised DER Signature Sequence**
* `30` - DER prefix
* `45` - Length of rest of Signature
* `02` - Marker for r value
* `21` - Length of r value
* `00ed...8f` - r value, Big Endian
* `02` - Marker for s value
* `21` - Length of s value
* `7a98...ed` - s value, Big Endian

In Libbitcoin, the serialised DER signature is contained by the `der_signature` type. We will format our signature from the previous example this way.

**Example 4 (Part 2)**
```c++
//Format mySignature (r,s) as a DER signature sequence
der_signature myDerSignature;
encode_signature(myDerSignature, mySignature);

//DER Signature Format (Strict DER Signature)
std::cout << encode_base16(myDerSignature);
```
**Strict DER Signatures (BIP66)**  
Bitcoin implementations have relied on OpenSSL for signing and verification in DER formats, although OpenSSL releases have deviated from the strict DER standard.

For example, the DER standard does not allow `r,s` values with first byte values of `>0x7F`, whilst this is simply ignored by OpenSSL. BIP66 was proposed to enforce strict DER adherence and is implemented in Libbitcoin.

We can use a simple parser function to ensure a DER signature adheres to strict DER encoding rules.

**Example 4 (Part 3)**
```c++
//Extract r,s values from myDerSignature
//Strict enforcement of DER = true
parse_signature(mySignature, myDerSignature, true);
```

## Recoverable Signatures
An interesting property of `secp256k1` signatures is that together with the signed message, it is possible to derive a set of 4 possible pubkey's without any knowledge of the private key.

Given `r,s` and an index `i` ranging from 0 to 3, it is therefore possible to uniquely identify the public key used in the signature. The signature and recovery index are contained in the Libbitcoin type `recoverable_signature`.

**Example 4 (Part 4)**
```c++
recoverable_signature myRecoverableSig;
sign_recoverable(myRecoverableSig, mySecret, myHash);
std::cout << unsigned(myRecoverableSig.recovery_id);

//recover public key from recoverable signature
ec_compressed recoveredSig;
recover_public(recoveredSig, myRecoverableSig, myHash);

std::cout << (recoveredSig == myPubKey);
```

Recoverable Signatures are used in message signing by Bitcoin wallets to prove control over a given Bitcoin address.

[**Next** -- Bitcoin Addresses &  Wallets](https://github.com/libbitcoin/libbitcoin/wiki)  
[**Previous** -- Working with Binary Data ](https://github.com/libbitcoin/libbitcoin/wiki)  
[**Return to Index**](https://github.com/libbitcoin/libbitcoin/wiki)
