# Elliptic Curve Operations & Signing

Libbitcoin provides all the necessary elliptic curve primitives and operations required for the generation and management of Bitcoin private keys, public keys and signatures of transactions and messages.

Bitcoin uses the `secp256k1` elliptic curve `y^2 = x^3 + 7` over the finite field `Fp` where `p = 2^256 - 2^32 - 2^9 - 2^8 - 2^7 - 2^6 - 2^4 - 1`.   

*(Note that modulo prime number `p` is slightly less than the maximum value an unsigned 256 bit integer can hold.)*

All subsequent operations involve either scalar members of the finite field `Fp` or valid points on the `secp256k1` curve.

## Scalar Operations

Let us start with scalar values. A Bitcoin private key is simply a secret scalar value which is a the member of the finite field `Fp`.

A private key is randomly generated to prevent any external party from reconstructing it systematically.
```c++
#include <bitcoin/bitcoin.hpp>
#include <string.h>
#include <iostream>

//Namespace
using namespace bc;
```
<!-- **Example 1** -->
```c++
//Generate 256 bits of entropy.
data_chunk my_entropy(ec_secret_size); //256bits
pseudo_random_fill(my_entropy);

//Instantiate private key with 256 bits of Entropy
auto my_secret = to_array<ec_secret_size>(my_entropy);

//Not all possible 256bits are member of Fp
std::cout << verify(my_secret);
```

We can also add and multiply scalar values of the field `Fp` with `ec_add` and `ec_multiply`. Both operations are commutative.

<!-- **Example 2** -->
```c++
//Two scalar values which are members of Fp
auto my_scalar1 = base16_literal("f3c8f9a6198cca98f481edde13bcc031b1470a81e367b838fe9e0a9db0f5993d");
auto my_scalar2 = base16_literal("04c294ab836b61955e762547c561a45e4be88984dca06da959d47bf880fd92f4");

//Commutative addition:
ec_secret my_scalar1_add(my_scalar1);
ec_secret my_scalar2_add(my_scalar2);
ec_add(my_scalar1_add, my_scalar2);  //my_scalar1_add += my_scalar2 % p
ec_add(my_scalar2_add, my_scalar1);  //my_scalar2_add += my_scalar1 % p
std::cout << (my_scalar1_add == my_scalar2_add);

//Commutative multiplication:
ec_secret my_scalar1_mul(my_scalar1);
ec_secret my_scalar2_mul(my_scalar2);
ec_add(my_scalar1_mul, my_scalar2);  //my_scalar1_mul *= my_scalar2 % p
ec_add(my_scalar2_mul, my_scalar1);  //my_scalar2_mul *= my_scalar1 % p
std::cout << (my_scalar1_mul == my_scalar2_mul);
```
## Generating Public Key Points

A Bitcoin public key is simply a point on the `secp256k1` curve generated by multiplying the `secp256k1` generator point with the secret private key scalar value.  

Note that there are two Bitcoin formats that represent points on the `secp256k1` elliptic curve. The *uncompressed* point format has a single byte `04` prefix followed by 32 bytes representing the x-coordinate and another 32 bytes representing the y-coordinate.

**Uncompressed elliptic curve point format**
```C++
//04 Prefix, x-Coordinate, y-Coordinate  (1 + 32 + 32 bytes)
0428026f91e1c97db3f6453262484ef5f69f71d89474f10926aae24d3c3eeb5f00c41b6810b8b305a05de2b4448d7e2a079771d4c018b923a9ab860e4b0b4f86f6
```

The *compressed* curve point format has a leading `02/03` byte followed by 32 bytes of the x-coordinate. The y-coordinate is omitted, yet implied by the x-coordinate and the prefix marker which indicates an even `(02)` or odd `(03)` y-coordinate.

**Compressed elliptic curve point format**
```c++
//02 or 03 Prefix, x-Coordinate(1 + 32 bytes)
0228026f91e1c97db3f6453262484ef5f69f71d89474f10926aae24d3c3eeb5f00
```
We will use the uncompressed format in our following examples to generate a Bitcoin public key curve point from a scalar private key.

<!-- **Example 3** -->
```c++
//Private Key
auto my_secret = base16_literal("f3c8f9a6198cca98f481edde13bcc031b1470a81e367b838fe9e0a9db0f5993d");

//The secp256k1 Generator Point
auto gen_point = base16_literal("0279BE667EF9DCBBAC55A06295CE870B07029BFCDB2DCE28D959F2815B16F81798");

//Manually generating the public key
ec_compressed my_pubkey_compressed(gen_point);
ec_multiply(my_pubkey_compressed,my_secret);

//Better: Using helper fct to generate the public key
ec_compressed my_pubkey2;
secret_to_public(my_pubkey2, my_secret);

std::cout << (my_pubkey_compressed == my_pubkey2);
```

**Associativity of EC operators**  
Both scalar and point operations on the elliptic curve are associative meaning that `point = (r1 + r2) * G = r1 * G + r2 * G`. You can easily demonstrate this using the Libbitcoin elliptic curve operators documented so far.

EC associativity is an important mathematical property used by extended public keys in [HD Wallets](https://github.com/libbitcoin/libbitcoin/wiki)  .

## DER Signatures in Bitcoin
Signing a transaction in Bitcoin requires both the private key and the transaction hash. The signature itself is composed of two `secp256k1` scalar values `r,s`.

The Libbitcoin type `ec_signature` is a `byte_array<64u>` container which holds the two signature values `r,s`.

<!-- **Example 4 (Part 1)** -->
```c++
//Hash of an arbitrary msg
auto msg = base16_literal("04c294ab836b61955e762547c561a45e4be88984dca06da959d47bf880fd92f4");
hash_digest my_hash = bitcoin_hash(msg);

//My private & public keys
auto my_secret = base16_literal("f3c8f9a6198cca98f481edde13bcc031b1470a81e367b838fe9e0a9db0f5993d");
auto my_pubkey = base16_literal("02b974a3e9fe9ce1ca7f9bb86c114567a51cd8deb7157aeabcce46eb6138c3a1b3");

//Sign hash of TX with my private key
ec_signature my_signature; //r,s
sign(my_signature, my_secret, my_hash);

//Verify Signature
std::cout << verify_signature(my_pubkey, my_hash, my_signature) << "\n";
```
Although we have now correctly signed the serialised TX message and produced a valid signature `r,s`, it still needs to be represented in a valid DER serialisation format to be accepted on the Bitcoin network.  

**Serialised DER Signature Sequence**
* `30` - DER prefix
* `45` - Length of rest of Signature
* `02` - Marker for r value
* `21` - Length of r value
* `00ed...8f` - r value, Big Endian
* `02` - Marker for s value
* `21` - Length of s value
* `7a98...ed` - s value, Big Endian

In Libbitcoin, the serialised DER signature is contained by the `der_signature` type. We will format our signature from the previous example this way.

<!-- **Example 4 (Part 2)** -->
```c++
//Format my_signature (r,s) as a DER signature sequence
der_signature my_der_signature;
encode_signature(my_der_signature, my_signature);

//DER Signature Format (Strict DER Signature)
std::cout << encode_base16(my_der_signature);
```
**Strict DER Signatures (BIP66)**  
Bitcoin implementations have relied on OpenSSL for signing and verification in DER formats, although OpenSSL releases have deviated from the strict DER standard.

For example, the DER standard does not allow `r,s` values with first byte values of `>0x7F`, whilst this is simply ignored by OpenSSL. BIP66 was proposed to enforce strict DER adherence and is implemented in Libbitcoin.

We can use a simple parser function to ensure a DER signature adheres to strict DER encoding rules.

<!-- **Example 4 (Part 3)** -->
```c++
//Parse r,s values from my_der_signature
//Strict enforcement of DER = true
parse_signature(my_signature, my_der_signature, true);
```

## Recoverable Signatures
An interesting property of `secp256k1` signatures is that together with the signed message, it is possible to derive a set of 4 possible pubkey's without any knowledge of the private key.

Given `r,s` and an index `i` ranging from 0 to 3, it is therefore possible to uniquely identify the public key used in the signature. The signature and recovery index are contained in the Libbitcoin type `recoverable_signature`.

<!-- **Example 4 (Part 4)** -->
```c++
recoverable_signature my_recoverable_sig;
sign_recoverable(my_recoverable_sig, my_secret, my_hash);
//Conversion: uint8_t->unsigned int for visible ASCII output
std::cout << unsigned(my_recoverable_sig.recovery_id);

//recover public key from recoverable signature
ec_compressed recovered_sig;
recover_public(recovered_sig, my_recoverable_sig, my_hash);

std::cout << (recovered_sig == my_pubkey);
```

Recoverable Signatures are used in message signing by Bitcoin wallets to prove control over a given Bitcoin address.

[**Next** -- Bitcoin Addresses &  Wallets](https://github.com/libbitcoin/libbitcoin/wiki)  
[**Previous** -- Working with Binary Data ](https://github.com/libbitcoin/libbitcoin/wiki)  
[**Return to Index**](https://github.com/libbitcoin/libbitcoin/wiki)
